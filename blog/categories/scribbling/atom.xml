<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scribbling | Rabarar\'s Blog]]></title>
  <link href="http://rabarar.github.io/blog/categories/scribbling/atom.xml" rel="self"/>
  <link href="http://rabarar.github.io/"/>
  <updated>2015-07-07T11:39:40-04:00</updated>
  <id>http://rabarar.github.io/</id>
  <author>
    <name><![CDATA[Rob Baruch]]></name>
    <email><![CDATA[rabarar@yahoo.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang Scribbles]]></title>
    <link href="http://rabarar.github.io/blog/2015/07/07/golang-scribbles/"/>
    <updated>2015-07-07T11:05:41-04:00</updated>
    <id>http://rabarar.github.io/blog/2015/07/07/golang-scribbles</id>
    <content type="html"><![CDATA[<p>So I was <a href="bored.com"><strong>bored</strong></a> an thought I&rsquo;d write some go code to demonstrate a few interesting features in Go!</p>

<p>Take a look at</p>

<pre><code>package main

import (
        "fmt"
        "sync"
        "time"
)

const (
        MAXFUNCS = 100
)

func main() {

        var x struct {
                sync.Mutex
                y func(int) int
                z int
        }

        var xx = make(chan struct {
                sync.Mutex
                y func(int) int
                z int
        })

        for i := 0; i &lt; MAXFUNCS; i++ {
                go func(num int) {
                        x.Lock()
                        x.y = z
                        x.z = x.y(42 * num)
                        fmt.Printf("x.z = %d\n", x.z)
                        xx &lt;- x
                        x.Unlock()
                }(i)
        }

        to := 0
        gets := 0

        for {
                select {
                case num := &lt;-xx:
                        to = 0
                        fmt.Printf("got %d\n", num.z)
                        gets++
                default:
                        fmt.Printf("sleeping...\n")
                        time.Sleep(1 * time.Second)
                        to++
                }

                if to &gt; 5 {
                        break
                }
        }

        fmt.Printf("received %d gets before timeout\n", gets)

}

func z(w int) int {
        return w / 2
}
</code></pre>

<p>Here I want to highlight a few cool concepts in Go:</p>

<ul>
<li>Anonymous structures</li>
<li>Bi-directional Channels</li>
<li>Go Routines</li>
<li>Non-blocking Channels</li>
<li>Anonymous fields in structures</li>
<li>Closures</li>
</ul>


<p>This toy program defines a variable <em>x</em> that is an anonymous struct that has an anonymous field that is a <code>sync.Mutux</code>. Why make this field anonymous? Well, by doing so, we can <code>Lock()</code> and <code>Unlock()</code> the structure without needlessly specifying a fieldname. Simply <code>x.Lock()</code> will lock the Mutux.</p>

<p>Next we create a channel of type that&rsquo;s equivalent to the unnamed stucture type. We do this by mirroring the definition of the unnamed structure in the variable definition.</p>

<p>Now that we&rsquo;ve defined our variables, we create a bunch of go routines using a function closure. We define a function that takes an <code>int</code> as our closure. We then <code>Lock()</code> our variable, assign a function to memeber <code>x.y</code> and call the function passing in the integer and returning the result to <code>x.z</code>. Now that we&rsquo;ve assigned values to <code>xxx</code> we pass it down the channel <code>xx</code>. Lastly we <code>Unlock()</code> the Mutux.</p>

<p>At this point we&rsquo;ve fired up a bunch of go routines, and sent copies of our anonymous struct down the channel.</p>

<p>Next we start and infinite loop (yike!) and check our channel for results in our main go-routine.</p>

<p>The first <code>case</code> in the <code>select</code> checks to see if we&rsquo;ve received a message on the channel. If we have we print out the value that we assigned to our integer field in our anonymous structure and tally the reeipt of a message on the channel.</p>

<p>If we don&rsquo;t receive a message, we default to our <code>default</code> case where we manage a timeout counter, <code>to</code>, After 5 consecutive seconds of not receiving any messages, we break our infinite loop, and report a timeout and display how many messages we received prior to timing out.</p>

<p>What might make this example more interesting is to delay each go routine by a random amount of time and see what if we complete prior to reeiving all of the messages.</p>

<p>Try modifying the function z as follows and see what happens</p>

<pre><code>func z(w int) int {
        time.Sleep(time.Duration(rand.Intn(5)) * time.Second)
}
</code></pre>

<p>This more realistically shows you how the Non-blocking channel works when reading mesages at an unpredictable rate.</p>
]]></content>
  </entry>
  
</feed>
